## 介绍
这是Memci的上下文管理设计文档

## 基本抽象
- **MessageNode**: 消息链表的节点，包含消息内容和前后节点指针
- **Entry**: entry 上下文系统最小单位，一个 entry 对应 MessageList 中的一个 MessageNode（Entry 持有 Node 的引用）
- **Page**: page 是上下文系统管理的基本单位，采用**视图模式**，作为 Chapter.MessageList 中一段连续节点的视图。一个 page 逻辑上对应与用户的一次交互产生的多条 entry（一条用户 entry 以及多条 assistant 或 tool entry），上下文系统对于上下文的卸载和召回以 page 为单位
- **Chapter**: chapter 是一组相关 page 的集合，维护**统一的 MessageList**。chapter 对于 LLM 来说是不可见，是上下文管理的关键。chapter 能够将其拥有的所有页卸载出上下文窗口，并生成一个 Contents Page 放入上下文窗口
- **Contents Page**: 目录页是上下文系统为 LLM 提供的压缩视图，LLM 可以通过目录页看到被卸载出上下文窗口的 Page 的 index，LLM 可以通过 index 召回 Page
- **Segment**: Segment 拥有一个或多个 Chapter，Segment 是提供给开发者从一个宏观视角组织上下文的一个抽象，目前上下文系统支持的 Segment 有 System Segment（系统提示词部分）、Common Segment（用户交互上下文部分）

## 架构设计：视图模式

### 核心设计理念

传统设计中，每个 Page 拥有独立的 Entry 列表，每次调用 `ToMessageList()` 都会创建新的 MessageList 副本，导致：
1. **数据冗余**：多份 MessageList 副本，内存占用高
2. **连接断裂**：不同 Page 的 Node 之间无法正确连接
3. **Detach 无效**：操作 Page.Entries 不会影响 MessageList

新的**视图模式**设计解决了这些问题：
- **单一数据源**：Chapter 维护统一的 MessageList
- **Page 是视图**：Page 只是引用 MessageList 中的一段节点范围（head 到 tail）
- **自动连接**：不同 Page 的 Node 自动形成连续链表
- **Detach 可靠**：Page.Detach() 直接从 Chapter.MessageList 断开节点

### 数据结构关系

```
┌─────────────────────────────────────────────────────────────────┐
│ Chapter (BaseChapter)                                           │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│  msgList: MessageList ──► [NodeA]↔[NodeB]↔[NodeC]↔[NodeD]↔[NodeE]│
│                                        ▲          ▲          ▲   │
│                                        │          │          │   │
│  pages: map[PageIndex]*Page ────────┬──┴──────────┴──────────┘   │
│                                     │                          │
└─────────────────────────────────────┼──────────────────────────┘
                                      │
              ┌────────────────────────┴────────────────────────┐
              │                                                 │
              ▼                                                 ▼
    ┌──────────────────┐                            ┌──────────────────┐
    │ Page #1          │                            │ Page #2          │
    ├──────────────────┤                            ├──────────────────┤
    │ head = NodeA     │                            │ head = NodeC     │
    │ tail = NodeB     │                            │ tail = NodeE     │
    │ Entries (view)   │                            │ Entries (view)   │
    │  └─ Entry1 (NodeA)│                            │  └─ Entry3 (NodeC)│
    │  └─ Entry2 (NodeB)│                            │  └─ Entry4 (NodeD)│
    └──────────────────┘                            │  └─ Entry5 (NodeE)│
                                                   └──────────────────┘
```

### 关键方法

#### Chapter.AddPage(page)
```go
// 1. 设置 Page 的 chapter 引用
page.chapter = bc

// 2. 将 Page 的所有 Node 添加到 msgList（不重置 next/prev）
for _, entry := range page.Entries {
    bc.msgList.AddNodeWithoutReset(entry.Node)
}

// 3. 设置 Page 的 head 和 tail
page.head = page.Entries[0].Node
page.tail = page.Entries[len(page.Entries)-1].Node
```

#### Chapter.ToMessageList()
```go
// 直接返回统一的 msgList（不创建副本）
return bc.msgList
```

#### Chapter.RemovePageRange(page)
```go
// 1. 获取前驱和后继节点
prevNode := page.head.GetPrev()  // 前一个 Page 的最后一个节点
nextNode := page.tail.GetNext()  // 后一个 Page 的第一个节点

// 2. 连接前驱和后继（跳过当前 Page 的所有节点）
prevNode.SetNext(nextNode)
nextNode.SetPrev(prevNode)

// 3. 清空 Page 的引用
page.head = nil
page.tail = nil
page.chapter = nil
```

#### Page.Detach()
```go
// 调用 Chapter 的 RemovePageRange 方法
p.chapter.RemovePageRange(p)
```

### 视图模式的优势

| 特性 | 传统模式 | 视图模式 |
|------|---------|---------|
| **数据源** | 每次创建新的 MessageList | Chapter 维护唯一的 MessageList |
| **内存占用** | 多份副本，内存高 | 单一数据源，内存高效 |
| **链表连接** | 每次 AddNode 重置指针 | Node 自动形成连续链表 |
| **Detach 操作** | 操作 Page.Entries，不影响 MessageList | 直接从 MessageList 断开，立即生效 |
| **数据一致性** | 多副本可能不一致 | 单一数据源，始终一致 |
| **跨 Page 遍历** | 需要手动拼接 | 直接遍历 Chapter.msgList |

### 序列化与持久化

**序列化时**（Save）：
1. 使用 `MessageNode.MarshalJSON()` 只序列化 msg 数据
2. 不序列化 next/prev 指针
3. 保存到存储

**反序列化时**（Load）：
1. 创建新的 Entry 和 MessageNode
2. 调用 `rebuildNodeLinks()` 重建 Page 内部的链表连接
3. 调用 `Chapter.AddPage()` 重新添加到 MessageList，重建跨 Page 的连接

## 上下文管理策略
### Segment层次
Segment将整个上下文分为 System Segment 和 Common Segement

### 卸载策略
1. 目前System Segement仅拥有一个System chapter
2. Common Segment管理 ArchiveChapter 和 ActiveChapter
   1. ArchiveChapter表示原始page已经被卸载出上下文窗口，但保留了一个Contents Page记录了摘要信息和索引，用于给llm召回
   2. ActiveChapter管理最近 n page，它管理的page直接放在上下文窗口里
3. ActiveChapter超出n page部分会给ArchiveChapter进行归档
4. ArchiveChapter会将新进的Page进行逐个entry摘要，生成 page index，放入 contents Page，然后将原始page卸载到文件系统
5. ArchiveChapter会记录每个Page被索引次数，卸载按照如下规则：
   1. m 轮对话后还是索引=0 -> 卸载
   2. contents page达到MaxToken限制，按照 LRU策略卸载
   3. p轮对话后索引次数没变过 -> 卸载
6. 被彻底卸载的page并没有从此消失，而是可以由记忆系统检索，但模型无法直接感知其存在

### 召回策略
1. Contents Page设计规则：
   1. 每个page都有一个唯一的index
   2. 每个page中的每条entry都进行摘要，放在对应page条目下，作为llm回忆的锚点
2. 在系统提示词中提供召回的原生工具，工具协议按照 @ATTP.md 
3. LLM根据ATTP协议调用工具召回page
4. 系统更新召回page的召回时间，召回次数


### 示意图

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                           层次结构                                            │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│  MessageNode ◄──► MessageNode ◄──► MessageNode ◄──► MessageNode            │
│       │                  │                  │                  │             │
│       │                  │                  │                  │             │
│  Entry 引用         Entry 引用         Entry 引用         Entry 引用       │
│                                                                             │
│  ┌─────────────────────────────────┐  ┌─────────────────────────────────┐  │
│  │           Page #1 (视图)         │  │           Page #2 (视图)         │  │
│  │  head ────────► 指向第一个 Node  │  │  head ────────► 指向第三个 Node  │  │
│  │  tail ────────► 指向第二个 Node  │  │  tail ────────► 指向第四个 Node  │  │
│  │  Entries (懒加载视图)            │  │  Entries (懒加载视图)            │  │
│  └─────────────────────────────────┘  └─────────────────────────────────┘  │
│           │                                   │                             │
│           └───────────────┬───────────────────┘                             │
│                           ▼                                                 │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │                    Chapter (BaseChapter)                            │   │
│  │  ┌─────────────────────────────────────────────────────────────┐   │   │
│  │  │           msgList: MessageList (统一数据源)                   │   │   │
│  │  │  [NodeA] ◄──► [NodeB] ◄──► [NodeC] ◄──► [NodeD]              │   │   │
│  │  │    ▲            ▲            ▲            ▲                   │   │   │
│  │  │    └──Page#1───┘            └──Page#2───┘                   │   │   │
│  │  └─────────────────────────────────────────────────────────────┘   │   │
│  │                                                                     │   │
│  │  pages: {0: Page#1, 1: Page#2, ...}                                │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                           │                                                 │
│                           ▼                                                 │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │                        Segment                                      │   │
│  │  ┌─────────────────────────────────────────────────────────────┐   │   │
│  │  │           Chapter1 + Chapter2 (不同类型的 Segment)            │   │   │
│  │  └─────────────────────────────────────────────────────────────┘   │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────────────────┐
│                        Page Detach 操作流程                                  │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│  初始状态:                                                                  │
│  ┌─────────┐      ┌─────────┐      ┌─────────┐      ┌─────────┐            │
│  │ NodeA   │ ◄──► │ NodeB   │ ◄──► │ NodeC   │ ◄──► │ NodeD   │            │
│  │ (P1#1)  │      │ (P1#2)  │      │ (P2#1)  │      │ (P2#2)  │            │
│  └─────────┘      └─────────┘      └─────────┘      └─────────┘            │
│    ▲                                 ▲                                  ▲           │
│    └──────── Page #1 ────────────────┘                                  │
│                                      ▲                                   │
│                                      └──────── Page #2 ───────────────────│
│                                                                             │
│  执行 Page #2.Detach():                                                   │
│                                                                             │
│  1. Page #2 调用 chapter.RemovePageRange(page)                              │
│  2. 获取前驱节点 (NodeB) 和后继节点 (NodeD)                                │
│  3. 连接前驱和后继: NodeB.next = NodeD, NodeD.prev = NodeB                │
│  4. 清空 Page #2 的 head/tail 引用                                         │
│                                                                             │
│  结果状态:                                                                  │
│  ┌─────────┐      ┌─────────┐                                            │
│  │ NodeA   │ ◄──► │ NodeB   │ ◄═════════════════════════╗ (跳过 Page#2) │
│  │ (P1#1)  │      │ (P1#2)  │                           ▼                  │
│  └─────────┘      └─────────┘                    ┌─────────┐              │
│                                                │ NodeD   │              │
│                                                │ (P2#2)  │              │
│                                                └─────────┘              │
│                                                                             │
│  Page #1: head=NodeA, tail=NodeB (保持不变)                               │
│  Page #2: head=nil, tail=nil (已 Detach)                                  │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

┌─────────────────────────────────────────────────────────────────────────────┐
│                      上下文窗口布局 (Context Window)                         │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│  ┌──────────────────────────────────────────────────────────────────────┐  │
│  │                    System Segment                                     │  │
│  │  ┌────────────────────────────────────────────────────────────────┐  │  │
│  │  │  System Chapter: 系统提示词 + 召回工具 (ATTP 协议)             │  │  │
│  │  └────────────────────────────────────────────────────────────────┘  │  │
│  ├──────────────────────────────────────────────────────────────────────┤  │
│  │                    Common Segment                                     │  │
│  │  ┌────────────────────────────────────────────────────────────────┐  │  │
│  │  │  ArchiveChapter → Contents Page (压缩视图)                     │  │  │
│  │  │  ┌──────────────────────────────────────────────────────────┐  │  │  │
│  │  │  │ [Page #42] 用户询问如何优化查询                          │  │  │  │
│  │  │  │   └─ User: 如何优化数据库查询...                         │  │  │  │
│  │  │  │   └─ Assistant: 建议添加索引...                          │  │  │  │
│  │  │  │   └─ 召回次数: 2, 最后召回: 5轮前                         │  │  │  │
│  │  │  │                                                          │  │  │  │
│  │  │  │ [Page #18] 用户讨论 API 设计                             │  │  │  │
│  │  │  │   └─ User: REST 还是 GraphQL...                          │  │  │  │
│  │  │  │   └─ Assistant: 推荐使用 REST...                          │  │  │  │
│  │  │  │   └─ 召回次数: 0, 最后召回: 12轮前                        │  │  │  │
│  │  │  └──────────────────────────────────────────────────────────┘  │  │  │
│  │  ├────────────────────────────────────────────────────────────────┤  │  │
│  │  │  ActiveChapter (最近 n 个 Page，完整内容)                     │  │  │
│  │  │  ┌──────────────────────────────────────────────────────────┐  │  │  │
│  │  │  │ Page #99: [完整 Entry1, Entry2, Entry3...]              │  │  │  │
│  │  │  │ Page #100: [完整 Entry1, Entry2, Entry3...]             │  │  │  │
│  │  │  │ ...                                                       │  │  │  │
│  │  │  │ Page #105: [完整 Entry1, Entry2, Entry3...]             │  │  │  │
│  │  │  └──────────────────────────────────────────────────────────┘  │  │  │
│  │  └────────────────────────────────────────────────────────────────┘  │  │
│  └──────────────────────────────────────────────────────────────────────┘  │
│                              ▲                                               │
│                              │ 上下文窗口边界                                │
└─────────────────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────────────────┐
│                          卸载与召回流程                                       │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│    ┌─────────────┐         ┌──────────────┐         ┌─────────────┐        │
│    │ 新 Page 进入 │ ───n满──►│ 归档到       │ ───立即──►│ Page 卸载到  │        │
│    │ ActiveChapter│         │ ArchiveChapter│   卸载    │ 文件系统     │        │
│    └─────────────┘         └──────────────┘         └─────────────┘        │
│                                     │                                       │
│                                     ▼                                       │
│                            ┌──────────────┐                                │
│                            │ 生成 Contents│                                │
│                            │ Page 条目     │                                │
│                            │ (摘要+索引)   │                                │
│                            └──────────────┘                                │
│                                     │                                       │
│                                     ▼                                       │
│    ┌─────────────┐         ┌──────────────┐   ┌─────────────┐            │
│    │ LLM 调用     │ ◄──ATTP─┤  Contents    │◄──│ 条目卸载条件 │            │
│    │ 召回工具     │         │  Page 条目   │   │ 触发         │            │
│    └─────────────┘         └──────────────┘   └─────────────┘            │
│           │                       │                                        │
│           ▼                       ▼                                        │
│    ┌─────────────┐         ┌──────────────┐                                │
│    │ 从文件系统  │         │ 条目被删除   │                                │
│    │ 恢复 Page   │         │ (模型无法感知)│                                │
│    │ 插入窗口    │         └──────────────┘                                │
│    └─────────────┘              │                                        │
│           │                     ▼                                        │
│           ▼              ┌──────────────┐                                │
│    ┌─────────────┐        │ 由记忆系统   │                                │
│    │ 更新召回统计 │        │ 检索召回     │                                │
│    │ (时间+次数)  │        └──────────────┘                                │
│    └─────────────┘                                                          │
│                                                                             │
│  条目卸载条件 (从 Contents Page 删除):                                       │
│  1. m 轮对话后 召回次数 = 0                                                  │
│  2. Contents Page 达到 MaxToken，按 LRU 卸载                                │
│  3. p 轮对话后 召回次数未变化                                                │
│                                                                             │
│  说明:                                                                      │
│  - Page 进入 ArchiveChapter 后立即卸载到文件系统，只保留 Contents Page 条目   │
│  - 条目卸载后，Page 对模型完全不可见，只能由记忆系统检索召回                  │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```


## 上下文管理系统 vs 记忆管理系统
- 上下文管理系统决定模型上下文窗口应该存在一些什么信息
- 记忆管理系统决定应该把什么信息持久化到外部文件，如何从外部文件检索记忆信息，如何通过处理记忆信息提升Agent与用户的适配度